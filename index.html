<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Carousel Journey of Gama & Asti</title>
  <style>
    :root{ --bg:#ffffff; --fg:#555555; --muted:#8a8a8a; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0; background:var(--bg); color:var(--fg); font:300 16px/1.75 'Open Sans', system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow:hidden }
    #app{position:fixed; inset:0}
    #caption{ position:fixed; left:50%; bottom:28px; transform:translateX(-50%); text-align:center; letter-spacing:.3px; color:var(--muted); font-size:18px; user-select:none; pointer-events:none; z-index:10 }
    #hint{ position:fixed; right:16px; bottom:16px; opacity:.65; font-size:12px; color:#888; user-select:none; pointer-events:none; z-index:10 }
    canvas{display:block}
    /* Lightbox overlay */
    #fadeOverlay{ position:fixed; inset:0; background:#000; opacity:0; pointer-events:none; transition:opacity .18s ease-out; z-index:5 }
    #fadeOverlay.visible{ opacity:.3; pointer-events:auto }
    /* Lightbox centered */
    #lightbox{ position:fixed; left:50%; top:50%; transform:translate(-50%,-50%) scale(.98); opacity:0; z-index:6; pointer-events:none; display:none; transition:transform .2s cubic-bezier(.2,.8,.2,1), opacity .15s ease-out; display:flex; flex-direction:column; align-items:center; width:min(560px,60vw) }
    #lightbox.visible{ display:flex; opacity:1; transform:translate(-50%,-50%) scale(1); pointer-events:auto }
    #lightbox img{ width:100%; height:auto; max-height:60vh; display:block; border-radius:0; box-shadow:0 18px 70px rgba(0,0,0,.28) }
    #lightCaption{ margin-top:10px; text-align:center; color:#444; font-size:13px; line-height:1.5; width:100% }
    /* Phase (minimal) */
    #phaseBar{ position:fixed; left:50%; top:64px; bottom:auto; transform:translateX(-50%); width:min(720px,68vw); border:none; border-radius:0; padding:0; background:transparent; color:#4f4f4f; z-index:9; box-shadow:none }
    #phaseTitle{ font-weight:300; color:#555; margin-bottom:8px; text-align:center; letter-spacing:.02em; font-size:12px }
    #phaseText{ font-size:12px; color:#777; text-align:center; line-height:1.8; letter-spacing:.1px }
    #hero{ position:fixed; top:20px; left:50%; transform:translateX(-50%); text-align:center; z-index:9; pointer-events:none }
    #hero h1{ margin:0; font-size:28px; letter-spacing:.5px; font-weight:300 }
    #hero h2{ margin:6px 0 0; font-size:14px; font-weight:300; color:#666 }
    #copyright{ position:fixed; bottom:16px; left:16px; color:#888; font-size:12px; user-select:none; z-index:10 }
    /* Gate overlay */
    #gate{ position:fixed; inset:0; background:#fff; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:10px; z-index:20; cursor:pointer; transition:opacity .2s ease-out }
    #gate.hidden{ opacity:0; pointer-events:none; display:none }
    #gate .to{ font-size:14px; color:#444 }
    #gate .cta{ font-size:22px; font-weight:300 }
    b,strong{font-weight:300}
  </style>
  <!-- Google Fonts: Open Sans Light/Regular -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;600&display=swap" rel="stylesheet">
  <!-- Import map so ESM bare specifiers resolve in this environment. -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="gate" role="button" aria-label="Click to open">
    <div class="to">To : <b>Arfan Ikhsan</b></div>
    <div class="cta">Click to open</div>
  </div>
  <div id="hero">
    <h1>THE CAROUSEL JOURNEY</h1>
    <h2>The wedding of Gama and Asti</h2>
  </div>
  <div id="app"></div>
  <div id="phaseBar">
    <div id="phaseTitle">Phase 1</div>
    <div id="phaseText">Loading story…</div>
  </div>
  <div id="fadeOverlay" aria-hidden="true"></div>
  <div id="lightbox" aria-live="polite">
    <img id="lightImg" alt="Selected photo" />
    <div id="lightCaption"></div>
  </div>
  <div id="copyright">© Arfan Ikhsan 2025</div>
  <div id="hint">Hover a photo to pause • Move off to resume • On mobile, press & hold to pause</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ---- Config -----------------------------------------------------------
    const CONFIG = {
      radius: 42,
      photoWidth: 12,
      photoHeight: 8,
      baseSpin: 0.05,
      scrollSpinScale: 0.00035,
      dragSpinScale: 0.0025,
      flingScale: 0.0008,
      maxSpinVel: 2.5,
      damping: 0.92,
      hoverScale: 1.12,
      selectScale: 1.25,
      gapAngle: 0,
      focusScale: 1.8,
      adjacentFactor: 0.7,
      influenceNeighbors: 10,
      scaleLerp: 18,
      grayLift: 0.35,
      colorLerp: 28
    };

    const HOLD_MS = 350; // press & hold duration (mobile) to pause

    // Replace with your own gallery
    const IMAGE_URLS = Array.from({length: 48}, (_, i) => `https://picsum.photos/seed/gamaAsti${i}/1200/800`);

    // ---- Renderer & Scene -------------------------------------------------
    const gate = document.getElementById('gate');
    const phaseTitle = document.getElementById('phaseTitle');
    const phaseText = document.getElementById('phaseText');
    const phaseBar = document.getElementById('phaseBar');
    let gateOpen = false;
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setClearColor(0xffffff, 1); // WHITE background
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera( 35, window.innerWidth/window.innerHeight, 0.1, 1000 );
    camera.position.set(0, 12, 110);
    scene.add(camera);

    // Lightbox DOM refs
    const overlay = document.getElementById('fadeOverlay');
    const lightbox = document.getElementById('lightbox');
    const lightImg = document.getElementById('lightImg');
    const lightCaption = document.getElementById('lightCaption');
    let lightOpen = false;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.enableZoom = true;
    controls.target.set(0,0,0);
    controls.minDistance = 40;
    controls.maxDistance = 180;
    controls.minPolarAngle = 0.2*Math.PI;
    controls.maxPolarAngle = 0.8*Math.PI;

    // Bright neutral lighting (no fog)
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 0.25);
    dir.position.set(10,20,10);
    scene.add(dir);

    // ---- Carousel ---------------------------------------------------------
    const carousel = new THREE.Group();
    scene.add(carousel);

    const loader = new THREE.TextureLoader();
    loader.crossOrigin = '';

    function makeSaturationMaterial(){
      return new THREE.ShaderMaterial({
        uniforms: {
          map: { value: null },
          uSaturation: { value: 1.0 },
          uLift: { value: 0.0 },
          uSatCurrent: { value: 1.0 },
          uLiftCurrent: { value: 0.0 },
          opacity: { value: 1.0 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D map;
          uniform float uSaturation;
          uniform float uLift;
          uniform float uSatCurrent;
          uniform float uLiftCurrent;
          uniform float opacity;
          varying vec2 vUv;
          void main(){
            vec4 tex = texture2D(map, vUv);
            float gray = dot(tex.rgb, vec3(0.2126, 0.7152, 0.0722));
            vec3 saturated = mix(vec3(gray), tex.rgb, clamp(uSatCurrent, 0.0, 1.0));
            vec3 lifted = mix(saturated, vec3(1.0), clamp(uLiftCurrent, 0.0, 1.0));
            gl_FragColor = vec4(lifted, tex.a * opacity);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: true
      });
    }

    const planeGeo = new THREE.PlaneGeometry(CONFIG.photoWidth, CONFIG.photoHeight, 1, 1);

    const N = IMAGE_URLS.length;
    const angleStep = (Math.PI*2 + CONFIG.gapAngle) / N;

    for (let i=0; i<N; i++){
      const angle = i * angleStep;
      const x = Math.sin(angle) * CONFIG.radius;
      const z = Math.cos(angle) * CONFIG.radius;

      const mat = makeSaturationMaterial();
      const m = new THREE.Mesh(planeGeo, mat);
      m.position.set(x, 0, z);
      m.lookAt(0, 0, 0);
      m.rotateY(-Math.PI/2);
      m.userData.defaultScale = 1;
      m.userData.angle0 = angle;
      m.userData.idx = i;
      m.userData.targetScale = 1;
      m.position.y = 0;

      loader.load(IMAGE_URLS[i], tex => {
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearMipMapLinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.anisotropy = 4;
        mat.uniforms.map.value = tex; mat.needsUpdate = true;
      });

      carousel.add(m);
    }

    // ---- Helper math ------------------------------------------------------
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function ringDistance(a,b){ const diff = Math.abs(a-b); return Math.min(diff, N - diff); }

    function angleOfMesh(m){ return m.userData.angle0 + carousel.rotation.y; }
    function screenXAtAngle(angle){
      const pos = new THREE.Vector3(Math.sin(angle)*CONFIG.radius, 0, Math.cos(angle)*CONFIG.radius);
      const p = pos.clone().project(camera);
      return (p.x*0.5 + 0.5) * window.innerWidth;
    }
    function defaultPixelsPerRad(){
      const a = carousel.rotation.y; // around the front
      const eps = 0.0005;
      return (screenXAtAngle(a+eps) - screenXAtAngle(a-eps)) / (2*eps) || (window.innerWidth/(Math.PI*2));
    }
    function updatePixelsPerRadForMesh(m){
      const a = angleOfMesh(m);
      const eps = 0.0005;
      let ppr = (screenXAtAngle(a+eps)-screenXAtAngle(a-eps))/(2*eps);
      if(!isFinite(ppr) || Math.abs(ppr)<1e-2) ppr = defaultPixelsPerRad();
      pixelsPerRad = ppr;
      return ppr;
    }

    // ---- Scaling field (instant & smooth setters) ------------------------
    function applyScaleField(centerIdx){
      for(let i=0;i<N;i++){
        const m = carousel.children[i];
        let s = 1;
        if(centerIdx != null){
          const d = ringDistance(i, centerIdx);
          s = Math.max(1, CONFIG.focusScale * Math.pow(CONFIG.adjacentFactor, d));
        }
        m.userData.targetScale = s;
        m.scale.setScalar(s);
      }
    }

    function applyScaleFieldSmooth(centerIdx){
      const R = Math.max(1, CONFIG.influenceNeighbors|0);
      const focus = CONFIG.focusScale;
      const g1 = Math.max(0, Math.min(1, (focus*CONFIG.adjacentFactor - 1) / (focus - 1)));
      const p = 2.0;
      const k = Math.pow(1 / ((1 / Math.max(1e-6, g1)) - 1), 1/p);
      for(let i=0;i<N;i++){
        const m = carousel.children[i];
        let s = 1;
        if(centerIdx != null){
          const d = ringDistance(i, centerIdx);
          const r = Math.min(d, R);
          const g = 1.0 / (1.0 + Math.pow(r / k, p));
          s = 1 + (focus - 1) * g;
        }
        m.userData.targetScale = s;
      }
    }

    // ---- Saturation (color vs grayscale with lift) -----------------------
    function applySaturation(centerIdx){
      for(let i=0;i<N;i++){
        const mesh = carousel.children[i];
        const isFocus = (centerIdx != null && i === centerIdx);
        const sat = (centerIdx == null) ? 1.0 : (isFocus ? 1.0 : 0.0);
        const lift = (centerIdx == null) ? 0.0 : (isFocus ? 0.0 : CONFIG.grayLift);
        if(mesh.material && mesh.material.uniforms){
          if(mesh.material.uniforms.uSaturation) mesh.material.uniforms.uSaturation.value = sat;
          if(mesh.material.uniforms.uLift) mesh.material.uniforms.uLift.value = lift;
        }
      }
    }

    // Initial: all images in color
    applySaturation(null);

    // ---- Interaction ------------------------------------------------------
    let spinVel = 0;
    let isFrozen = false;
    const clock = new THREE.Clock();

    let hovered = null;
    let pointerOverRing = false;

    // Drag state
    let draggingSpin = false;
    let mayDrag = false;
    let lastX = 0;
    let dragStartX = 0; let dragStartY = 0;
    let lastMoveT = 0;
    let dragVelocity = 0;
    let grabbed = null;
    let pixelsPerRad = 300;

    // Mobile hold-to-pause state
    let holdTimer = null;
    let holdActive = false;
    let holdIndex = null;
    let suppressClickOpen = false;

    function clearHold(){ if(holdTimer){ clearTimeout(holdTimer); holdTimer=null; } }
    function endHold(){ if(holdActive){ holdActive=false; isFrozen=false; } }

    function clampSpin(){
      const m = CONFIG.maxSpinVel; if(m>0){ spinVel = Math.max(-m, Math.min(m, spinVel)); }
    }
    function applyFling(pxPerSec){
      const ppr = defaultPixelsPerRad();
      spinVel += (pxPerSec / ppr); clampSpin();
    }
    function applyFlingRad(radPerSec){ spinVel += radPerSec; clampSpin(); }

    function intersectAt(clientX, clientY){
      pointer.x = (clientX / window.innerWidth) * 2 - 1;
      pointer.y = -(clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      return raycaster.intersectObjects(carousel.children, false);
    }

    function setHovered(obj){
      hovered = obj;
      pointerOverRing = !!hovered;
      let centerIdx = null;
      if(draggingSpin && grabbed){ centerIdx = grabbed.userData.idx; }
      else if(holdActive && holdIndex != null){ centerIdx = holdIndex; }
      else if(hovered){ centerIdx = hovered.userData.idx; }

      applyScaleFieldSmooth(centerIdx);
      applySaturation(centerIdx);
      if(!draggingSpin && !holdActive){ isFrozen = !!hovered; }
    }

    renderer.domElement.addEventListener('pointermove', (e)=>{
      const hits = intersectAt(e.clientX, e.clientY);
      setHovered(hits.length ? hits[0].object : null);

      const now = performance.now();
      const moveDX = e.clientX - dragStartX;
      const moveDY = e.clientY - dragStartY;
      const movedEnough = (Math.hypot(moveDX, moveDY) > 6);

      if(mayDrag && !draggingSpin && movedEnough){
        draggingSpin = true; controls.enabled = false; clearHold(); endHold();
        if(grabbed) applyScaleFieldSmooth(grabbed.userData.idx);
        applySaturation(grabbed.userData.idx);
      }

      if(draggingSpin && grabbed){
        const dx = e.clientX - lastX;
        const dt = Math.max(0.001, (now - lastMoveT) / 1000);
        const instV = dx / dt;
        dragVelocity = THREE.MathUtils.lerp(dragVelocity, instV, 0.25);
        updatePixelsPerRadForMesh(grabbed);
        const dAngle = dx / pixelsPerRad;
        carousel.rotation.y += dAngle;
        clampSpin();
        lastX = e.clientX;
        lastMoveT = now;
        isFrozen = false;
        applyScaleFieldSmooth(grabbed.userData.idx);
        applySaturation(grabbed.userData.idx);
        e.preventDefault();
      }
    }, { passive: false });

    renderer.domElement.addEventListener('wheel', (e)=>{
      if(pointerOverRing){
        spinVel += -e.deltaY * CONFIG.scrollSpinScale;
        e.preventDefault();
      }
    }, { passive: false });

    renderer.domElement.addEventListener('pointerdown', (e)=>{
      const hits = intersectAt(e.clientX, e.clientY);
      mayDrag = hits.length>0;
      grabbed = mayDrag ? hits[0].object : null;
      if(grabbed) updatePixelsPerRadForMesh(grabbed);
      lastX = e.clientX; dragStartX = e.clientX; dragStartY = e.clientY; lastMoveT = performance.now(); dragVelocity = 0;

      if(mayDrag){
        try{ renderer.domElement.setPointerCapture(e.pointerId); }catch{}
        if(e.pointerType === 'touch' || e.pointerType === 'pen'){
          clearHold(); holdIndex = grabbed ? grabbed.userData.idx : (hovered ? hovered.userData.idx : null);
          holdTimer = setTimeout(()=>{ if(!draggingSpin && mayDrag){ isFrozen = true; holdActive = true; applyScaleFieldSmooth(holdIndex); applySaturation(holdIndex); } }, HOLD_MS);
        }
      }
    });

    function finishPointer(e, doFling){
      if(draggingSpin){
        if(doFling){
          const radPerSec = dragVelocity / (pixelsPerRad || defaultPixelsPerRad());
          applyFlingRad(radPerSec);
        }
        if(e) e.preventDefault();
      }
      controls.enabled = true;
      draggingSpin = false; mayDrag = false; dragVelocity = 0; grabbed = null;
      clearHold(); endHold(); holdIndex = null;
      applyScaleFieldSmooth(hovered ? hovered.userData.idx : null);
      applySaturation(hovered ? hovered.userData.idx : null);
      if(e){ try{ renderer.domElement.releasePointerCapture(e.pointerId); }catch{} }
    }
    renderer.domElement.addEventListener('pointerup', (e)=>{
      const moved = Math.hypot(e.clientX - dragStartX, e.clientY - dragStartY) > 6;
      suppressClickOpen = draggingSpin || moved;
      finishPointer(e, true);
    });
    renderer.domElement.addEventListener('pointercancel', (e)=>{ suppressClickOpen = true; finishPointer(e, false); });

    function onResize(){
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    onResize();

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());

      if(!isFrozen){
        carousel.rotation.y += (CONFIG.baseSpin + spinVel) * dt;
      } else {
        spinVel *= 0.85;
      }
      spinVel *= CONFIG.damping;
      clampSpin();

      for(const m of carousel.children){
        const target = (m.userData && m.userData.targetScale) ? m.userData.targetScale : 1;
        const curr = m.scale.x;
        const t = Math.min(1, CONFIG.scaleLerp * dt);
        const next = curr + (target - curr) * t;
        if(Math.abs(next - curr) > 1e-4) m.scale.setScalar(next);
      }

      for(const m of carousel.children){
        const mat = m.material;
        if(!mat || !mat.uniforms) continue;
        const u = mat.uniforms;
        const tC = Math.min(1, CONFIG.colorLerp * dt);
        if(u.uSatCurrent && u.uSaturation){
          const curr = u.uSatCurrent.value, dst = u.uSaturation.value;
          u.uSatCurrent.value = curr + (dst - curr) * tC;
        }
        if(u.uLiftCurrent && u.uLift){
          const curr = u.uLiftCurrent.value, dst = u.uLift.value;
          u.uLiftCurrent.value = curr + (dst - curr) * tC;
        }
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ---- Phase text that advances when the front image changes ----------
    function loremPara(){ return phaseShortCaption(); }
    let phaseIndex = 1; let lastFrontIdx = -1;
    function updatePhase(frontIdx){
      if(frontIdx === lastFrontIdx) return;
      lastFrontIdx = frontIdx;
      phaseIndex = (phaseIndex % 6) + 1;
      phaseTitle.textContent = `Phase ${phaseIndex}`;
      phaseText.textContent = loremPara();
    }

    function computeFrontIndex(){
      let best = 0; let bestZ = -Infinity;
      for(let i=0;i<N;i++){
        const a = carousel.children[i].userData.angle0 + carousel.rotation.y;
        const z = Math.cos(a) * CONFIG.radius;
        if(z > bestZ){ bestZ = z; best = i; }
      }
      return best;
    }

    // Position the phase bar midway between ring bottom and footer top
    function updatePhaseBarPosition(frontIdx){
      if(frontIdx == null) frontIdx = computeFrontIndex();
      const m = carousel.children[frontIdx]; if(!m) return;
      const bottomLocal = new THREE.Vector3(0, -CONFIG.photoHeight*0.5*m.scale.y, 0);
      const worldBottom = m.localToWorld(bottomLocal.clone());
      const ndc = worldBottom.clone().project(camera);
      const ringBottomY = (-ndc.y * 0.5 + 0.5) * window.innerHeight;
      const hintEl = document.getElementById('hint');
      const copyEl = document.getElementById('copyright');
      const footTop = Math.min(hintEl.getBoundingClientRect().top, copyEl.getBoundingClientRect().top);
      const mid = Math.round(ringBottomY + (footTop - ringBottomY) * 0.5);
      phaseBar.style.top = mid + 'px';
      phaseBar.style.bottom = 'auto';
    }

    // call once and then check regularly
    updatePhase(computeFrontIndex());
    updatePhaseBarPosition(computeFrontIndex());
    setInterval(()=>{ const idx = computeFrontIndex(); updatePhase(idx); updatePhaseBarPosition(idx); }, 200);

    // ---- Gate overlay ----------------------------------------------------
    gate.addEventListener('click', ()=>{ gate.classList.add('hidden'); gateOpen = true; });

    // Shorter phase text (1–2 short sentences)
    function phaseShortCaption(){
      const s = [
        'Lorem ipsum dolor sit amet, consectetur adipiscing elit.',
        'Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
        'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.',
        'Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.',
        'Nulla porttitor accumsan tincidunt.'
      ];
      const n = 1 + Math.floor(Math.random()*2);
      let out = [];
      for(let i=0;i<n;i++) out.push(s[Math.floor(Math.random()*s.length)]);
      return out.join(' ');
    }

    // Randomize a paragraph caption (4–6 short sentences)
    function randomCaption(){
      const sentences = [
        'Lorem ipsum dolor sit amet, consectetur adipiscing elit.',
        'Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
        'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.',
        'Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.',
        'Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.',
        'Curabitur non nulla sit amet nisl tempus convallis quis ac lectus.',
        'Praesent sapien massa, convallis a pellentesque nec, egestas non nisi.',
        'Nulla porttitor accumsan tincidunt.'
      ];
      const n = 4 + Math.floor(Math.random()*3);
      const picks = [sentences[0]];
      for(let i=1;i<n;i++){
        picks.push(sentences[1 + Math.floor(Math.random()*(sentences.length-1))]);
      }
      return picks.join(' ');
    }

    // ---- Lightbox behavior ----------------------------------------------
    function openLightboxForMesh(mesh){
      if(!mesh || lightOpen) return;
      let src = null;
      let cap = randomCaption();
      if(mesh.material && mesh.material.uniforms && mesh.material.uniforms.map && mesh.material.uniforms.map.value){
        const tex = mesh.material.uniforms.map.value;
        if(tex.image && tex.image.src) src = tex.image.src;
      }
      if(!src && mesh.userData && typeof mesh.userData.idx==='number') src = IMAGE_URLS[mesh.userData.idx];
      if(!src) return;
      lightImg.src = src; 
      lightCaption.textContent = cap;
      overlay.classList.add('visible');
      lightbox.classList.add('visible');
      lightOpen = true; 
      isFrozen = true;
    }
    function openLightboxForIndex(i){ const m = carousel.children[i|0]; if(m) openLightboxForMesh(m); }
    function closeLightbox(){ 
      if(!lightOpen) return; 
      overlay.classList.remove('visible'); 
      lightbox.classList.remove('visible'); 
      try{ lightImg.removeAttribute('src'); }catch{} 
      lightOpen = false; 
      isFrozen = false; 
    }
    overlay.addEventListener('click', closeLightbox);
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeLightbox(); });

    renderer.domElement.addEventListener('click', (e)=>{
      if(suppressClickOpen || draggingSpin || holdActive){ suppressClickOpen = false; return; }
      const hits = intersectAt(e.clientX, e.clientY);
      if(hits.length) openLightboxForMesh(hits[0].object);
    });


      (function(){
        const mtest = carousel.children[0];
        const u = mtest.material.uniforms;
        u.uSatCurrent.value = 1.0;
        u.uSaturation.value = 0.0;
        const dtSim = 0.016;
        const tC = Math.min(1, CONFIG.colorLerp * dtSim);
        const expected = 1 + (0 - 1) * tC;
        u.uSatCurrent.value = u.uSatCurrent.value + (u.uSaturation.value - u.uSatCurrent.value) * tC;
        ok('Color easing step moves uSatCurrent toward target', Math.abs(u.uSatCurrent.value - expected) < 1e-6);
      })();

      if(typeof overlay!== 'undefined' && typeof lightbox !== 'undefined'){
        ok('Lightbox hidden at startup', !overlay.classList.contains('visible') && !lightbox.classList.contains('visible'));
        openLightboxForIndex(1);
        ok('Lightbox visible after open', overlay.classList.contains('visible') && lightbox.classList.contains('visible'));
        ok('Caption randomized', (lightCaption.textContent || '').length > 20 && !/Photo #/i.test(lightCaption.textContent));
        ok('Caption is lorem ipsum', /lorem|ipsum/i.test(lightCaption.textContent));
        const cs = getComputedStyle(lightbox);
        ok('Lightbox centered horizontally', cs.left === '50%');
        ok('Lightbox centered vertically', cs.top === '50%');
        closeLightbox();
        ok('Lightbox hidden after close', !overlay.classList.contains('visible') && !lightbox.classList.contains('visible'));
      }

      const passed = tests.filter(t=>t.pass).length;
      const badge = document.getElementById('testBadge');
      badge.textContent = `Tests: ${passed}/${tests.length} passed`;
      badge.style.background = passed===tests.length ? '#eef7ee' : '#fff4f4';
      badge.style.color = passed===tests.length ? '#145a1e' : '#7a1010';
      badge.style.borderColor = passed===tests.length ? '#bfe3c2' : '#ffd1d1';
      console.table(tests);
    })();
  </script>
</body>
</html>
